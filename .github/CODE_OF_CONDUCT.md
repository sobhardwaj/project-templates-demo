# Contributor Covenant Code of Conduct

## Project Structure

This is a ruleset that defines guides of a project structure management. Why does it exist? There are several reasons for that:
1. It is easier for teammates to help if you follow the common structure
2. It helps us to perform a code review and ensure the highest quality of your code
3. It implements the leading and proven software engineering practices

### Project level

The basic project level would look like this:

```
project-name
├── (.files)           – config files you don't need to touch
├── node_modules       – installed modules, no need to touch
├── packages           – folder for all independent apps
│   ├── cms            – content management app folder
│   └── website        – front-end app folder
├── .env               – main environment file
├── .env.dist          – main environment template
├── package.json       – project configurations and global scripts
├── README.md          – project readme
├── LICENSE            – license details
├── (*.lock files)     – autogenerated files
└── (*.yaml files)     – deployment and configs
└── (.*ignore files)   – ignore files
```

> * Most of the files on this level change rarely. If you write to a file here constantly, then there is a probability you are doing something wrong.
> * `.env` file is your own local file that should not go to git. You can find more about `.env` files in [this article](https://github.com/bn-digital/home/wiki/Secrets-Management)
> * `.lock` files are autogenerated. You can always delete and re-generate them in case you face conflicts.

### App level

The App level (cms, website, or something new) looks like this:

```
appname
├── (.folders)         – temporary folders you can ignore
├── build              – a folder with the generated build
├── node_modules       – installed modules, no need to touch
├── src                – your main folder
│   ├── components     – a folder with all custom components
│   ├── graphql        – a folder with all connectivity items
│   ├── types          – a folder with all custom type definitions
│   ├── ...            – other project-specific folders
│   └── index.tsx      – app entry point
├── .env               – main environment file
├── .env.*             – environment templates
├── Dockerfile         – containerization instructions for further deployment
├── package.json       – app configurations and global scripts
├── README.md          – app readme
├── tsconfig.json      – app typescript settings, don't touch
└── vite.config.ts     – app building config
```

> * You would find some app-specific files here and there, because of each app specifics.
> * `.env' file should be created manually followed by instructions.
> * `package.json` is the main place to add npm packages, run scripts, etc.
> * [`README.md`](README.md) should answer questions on what app does and how to run it.
> *  We strongly advise understanding how the app is compiled by reading the [`vite.config.ts`](packages/website/vite.config.ts) file.

### Sources level

The source code level (src) for a front-end app looks like this:

```
src
├── components              – a folder with all custom components
│   ├── app                 – base single-page app component
│   │   ├── index.less      – base CSS container that implements Ant styles and overrides
│   │   └── index.tsx       – generic app code
│   ├── layouts             – layouts folder
│   │   ├── index.tsx       – container for exporting
│   │   ├── <CompName>.tsx  – layout code
│   │   ├── <CompName>.less — layout styles
│   │   └── assets          — layout assets
│   ├── <compname>          – custom component you are coding
│   │   ├── <CompName>.tsx  – custom component code
│   │   ├── <CompName>.less — custom component styles
│   │   └── assets          — custom component assets
│   └── ...                 — your other component folders
├── graphql                 – a folder with all connectivity items
│   ├── fragments           – graphql fragments go here
│   ├── mutations           – graphql mutations go here
│   ├── queries             – graphql queries go here
│   └── index.tsx           – autogenerated, do not touch
├── types                   – a folder with all custom type definitions
│   └── <type>.d.ts         – type definition for TS autocomplete
├── pages                   – a folder to keep all pages
│   └── <pagename>          – a folder for a page
│       ├── index.tsx       – page implementation
│       └── (something).tsx – additional page related items (hooks, contexts)
├── index.tsx               – app entry point
└── index.less              – container for app-level variables
```

> * Keep `components` and `pages` folders flat, do not create a folder with folders inside.

## Naming conventions

### React Components
* Components **should** be named in `UpperCamelCase` exactly as `function` or `const` name, like `ComponentName.tsx`
* Module index files **should** be named as `index.tsx`

### Typescript
* Type definitions **should** named as `snake-case` with `.d.ts` extension like `app.d.ts`
* Helper functions, constants, modules etc **should** be named like `lowerCamelCase.ts`:

### Styles
* `.less` file **should** have the same name as it's component keeping same convention like `ComponentName.less`


## Code Style

### React Components

- Functional or class [components](https://reactjs.org/docs/components-and-props.html) **should** be named in `UpperCamelCase` convention:

```typescript jsx
import { FC } from "react"
import { useNavigate } from "react-router-dom"
import { Card } from "antd"

type SectionProps = {
  url: string
}

const Section: FC<SectionProps> = ({ url = "" }) => {
  const navigate = useNavigate()

  return <Card onClick={() => navigate(url)} />
}
```

- Use suffixes for sibling entities related to root one: `Props`, `Provider`, `Fragment`

```typescript jsx
type ModalProps = {
  visible: boolean
}

const defaultValue : ModalProps = { visible: false }

const ModalContext = createContext(defaultValue)

const Modal : FC = () => {
  return <ModalContext.Consumer>{({ visible })} => <div style={{ display: visible ? "initial" : "none" }} />}</ModalContext.Consumer>
}
```

- Use aliases when wrapping component with same name to keep same name as original one.

```typescript jsx
import { FC } from "react"
import { Modal as Wrapped } from "antd"

// Using type extension to enhance wrapped component with new props
type ModalProps = typeof Wrapped.defaultProps & {
  opacity: number
}

// Using Partial in-place to make all properties optional in one place
const Modal: FC<Partial<ModalProps>> = props => {
  // Using with destructuring assignment to separate new properties from origin
  const { children, opacity, className, style, ...modalProps } = props
  // Have to extract styles and class name to merge with enhanced
  return (
    <Wrapped className={[className, "modal-opaque"].join(" ")} style={{ ...style, opacity }} {...modalProps}>
      {children}
    </Wrapped>
  )
}
```

- Custom [hooks](https://reactjs.org/docs/hooks-intro.html) **should** be named in `lowerCamelCase` with `use` prefix:\

```typescript
function useCustomHook() {
  return { message: "Message from the void" }
}
```

- Custom [HOCs](https://reactjs.org/docs/higher-order-components.html) **should** be named in `lowerCamelCase` with `with` prefix:

```typescript jsx
import { FC, useLayoutEffect } from "react";
import { useLocation } from "react-router-dom";

function withScrollToTop<T>(Wrapped: FC<T>): FC<T> {
  return props => {
    const {pathname} = useLocation()

    useLayoutEffect(() => {
      window.scrollTo(0, 0)
    }, [pathname])

    return <Wrapped {...props} />
  }
}
```
